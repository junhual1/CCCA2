{"ast":null,"code":"import _slicedToArray from \"/Users/eddiediedie/Desktop/CCC_A2/CCCA2/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/eddiediedie/Desktop/CCC_A2/CCCA2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/eddiediedie/Desktop/CCC_A2/CCCA2/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/eddiediedie/Desktop/CCC_A2/CCCA2/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.math.fround.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/esnext.typed-array.to-reversed.js\";\nimport \"core-js/modules/esnext.typed-array.to-sorted.js\";\nimport \"core-js/modules/esnext.typed-array.with.js\";\nimport \"core-js/modules/es.object.create.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport KDBush from '../../../kdbush@3.0.0/node_modules/kdbush/src/index.js';\nvar defaultOptions = {\n  minZoom: 0,\n  // min zoom to generate clusters on\n  maxZoom: 16,\n  // max zoom level to cluster the points on\n  minPoints: 2,\n  // minimum points to form a cluster\n  radius: 40,\n  // cluster radius in pixels\n  extent: 512,\n  // tile extent (radius is calculated relative to it)\n  nodeSize: 64,\n  // size of the KD-tree leaf node, affects performance\n  log: false,\n  // whether to log timing info\n  // whether to generate numeric ids for input features (in vector tiles)\n  generateId: false,\n  // a reduce function for calculating custom cluster properties\n  reduce: null,\n  // (accumulated, props) => { accumulated.sum += props.sum; }\n  // properties to use for individual points when running the reducer\n  map: function map(props) {\n    return props;\n  } // props => ({sum: props.my_value})\n};\n\nvar fround = Math.fround || function (tmp) {\n  return function (x) {\n    tmp[0] = +x;\n    return tmp[0];\n  };\n}(new Float32Array(1));\nvar Supercluster = /*#__PURE__*/function () {\n  function Supercluster(options) {\n    _classCallCheck(this, Supercluster);\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n  }\n  _createClass(Supercluster, [{\n    key: \"load\",\n    value: function load(points) {\n      var _this$options = this.options,\n        log = _this$options.log,\n        minZoom = _this$options.minZoom,\n        maxZoom = _this$options.maxZoom,\n        nodeSize = _this$options.nodeSize;\n      if (log) console.time('total time');\n      var timerId = \"prepare \".concat(points.length, \" points\");\n      if (log) console.time(timerId);\n      this.points = points; // generate a cluster object for each point and index input points into a KD-tree\n\n      var clusters = [];\n      for (var i = 0; i < points.length; i++) {\n        if (!points[i].geometry) continue;\n        clusters.push(createPointCluster(points[i], i));\n      }\n      this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n      if (log) console.timeEnd(timerId); // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n      // results in a cluster hierarchy across zoom levels\n\n      for (var z = maxZoom; z >= minZoom; z--) {\n        var now = +Date.now(); // create a new set of clusters for the zoom and index them with a KD-tree\n\n        clusters = this._cluster(clusters, z);\n        this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n        if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n      }\n      if (log) console.timeEnd('total time');\n      return this;\n    }\n  }, {\n    key: \"getClusters\",\n    value: function getClusters(bbox, zoom) {\n      var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n      var minLat = Math.max(-90, Math.min(90, bbox[1]));\n      var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n      var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n      if (bbox[2] - bbox[0] >= 360) {\n        minLng = -180;\n        maxLng = 180;\n      } else if (minLng > maxLng) {\n        var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n        var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n        return easternHem.concat(westernHem);\n      }\n      var tree = this.trees[this._limitZoom(zoom)];\n      var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n      var clusters = [];\n      var _iterator = _createForOfIteratorHelper(ids),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var id = _step.value;\n          var c = tree.points[id];\n          clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return clusters;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(clusterId) {\n      var originId = this._getOriginId(clusterId);\n      var originZoom = this._getOriginZoom(clusterId);\n      var errorMsg = 'No cluster with the specified id.';\n      var index = this.trees[originZoom];\n      if (!index) throw new Error(errorMsg);\n      var origin = index.points[originId];\n      if (!origin) throw new Error(errorMsg);\n      var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n      var ids = index.within(origin.x, origin.y, r);\n      var children = [];\n      var _iterator2 = _createForOfIteratorHelper(ids),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var id = _step2.value;\n          var c = index.points[id];\n          if (c.parentId === clusterId) {\n            children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (children.length === 0) throw new Error(errorMsg);\n      return children;\n    }\n  }, {\n    key: \"getLeaves\",\n    value: function getLeaves(clusterId, limit, offset) {\n      limit = limit || 10;\n      offset = offset || 0;\n      var leaves = [];\n      this._appendLeaves(leaves, clusterId, limit, offset, 0);\n      return leaves;\n    }\n  }, {\n    key: \"getTile\",\n    value: function getTile(z, x, y) {\n      var tree = this.trees[this._limitZoom(z)];\n      var z2 = Math.pow(2, z);\n      var _this$options2 = this.options,\n        extent = _this$options2.extent,\n        radius = _this$options2.radius;\n      var p = radius / extent;\n      var top = (y - p) / z2;\n      var bottom = (y + 1 + p) / z2;\n      var tile = {\n        features: []\n      };\n      this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.points, x, y, z2, tile);\n      if (x === 0) {\n        this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.points, z2, y, z2, tile);\n      }\n      if (x === z2 - 1) {\n        this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.points, -1, y, z2, tile);\n      }\n      return tile.features.length ? tile : null;\n    }\n  }, {\n    key: \"getClusterExpansionZoom\",\n    value: function getClusterExpansionZoom(clusterId) {\n      var expansionZoom = this._getOriginZoom(clusterId) - 1;\n      while (expansionZoom <= this.options.maxZoom) {\n        var children = this.getChildren(clusterId);\n        expansionZoom++;\n        if (children.length !== 1) break;\n        clusterId = children[0].properties.cluster_id;\n      }\n      return expansionZoom;\n    }\n  }, {\n    key: \"_appendLeaves\",\n    value: function _appendLeaves(result, clusterId, limit, offset, skipped) {\n      var children = this.getChildren(clusterId);\n      var _iterator3 = _createForOfIteratorHelper(children),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var child = _step3.value;\n          var props = child.properties;\n          if (props && props.cluster) {\n            if (skipped + props.point_count <= offset) {\n              // skip the whole cluster\n              skipped += props.point_count;\n            } else {\n              // enter the cluster\n              skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped); // exit the cluster\n            }\n          } else if (skipped < offset) {\n            // skip a single point\n            skipped++;\n          } else {\n            // add a single point\n            result.push(child);\n          }\n          if (result.length === limit) break;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return skipped;\n    }\n  }, {\n    key: \"_addTileFeatures\",\n    value: function _addTileFeatures(ids, points, x, y, z2, tile) {\n      var _iterator4 = _createForOfIteratorHelper(ids),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var i = _step4.value;\n          var c = points[i];\n          var isCluster = c.numPoints;\n          var tags = void 0,\n            px = void 0,\n            py = void 0;\n          if (isCluster) {\n            tags = getClusterProperties(c);\n            px = c.x;\n            py = c.y;\n          } else {\n            var p = this.points[c.index];\n            tags = p.properties;\n            px = lngX(p.geometry.coordinates[0]);\n            py = latY(p.geometry.coordinates[1]);\n          }\n          var f = {\n            type: 1,\n            geometry: [[Math.round(this.options.extent * (px * z2 - x)), Math.round(this.options.extent * (py * z2 - y))]],\n            tags: tags\n          }; // assign id\n\n          var id = void 0;\n          if (isCluster) {\n            id = c.id;\n          } else if (this.options.generateId) {\n            // optionally generate id\n            id = c.index;\n          } else if (this.points[c.index].id) {\n            // keep id if already assigned\n            id = this.points[c.index].id;\n          }\n          if (id !== undefined) f.id = id;\n          tile.features.push(f);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"_limitZoom\",\n    value: function _limitZoom(z) {\n      return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n  }, {\n    key: \"_cluster\",\n    value: function _cluster(points, zoom) {\n      var clusters = [];\n      var _this$options3 = this.options,\n        radius = _this$options3.radius,\n        extent = _this$options3.extent,\n        reduce = _this$options3.reduce,\n        minPoints = _this$options3.minPoints;\n      var r = radius / (extent * Math.pow(2, zoom)); // loop through each point\n\n      for (var i = 0; i < points.length; i++) {\n        var p = points[i]; // if we've already visited the point at this zoom level, skip it\n\n        if (p.zoom <= zoom) continue;\n        p.zoom = zoom; // find all nearby points\n\n        var tree = this.trees[zoom + 1];\n        var neighborIds = tree.within(p.x, p.y, r);\n        var numPointsOrigin = p.numPoints || 1;\n        var numPoints = numPointsOrigin; // count the number of points in a potential cluster\n        var _iterator5 = _createForOfIteratorHelper(neighborIds),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _neighborId2 = _step5.value;\n            var _b2 = tree.points[_neighborId2]; // filter out neighbors that are already processed\n\n            if (_b2.zoom > zoom) numPoints += _b2.numPoints || 1;\n          } // if there were neighbors to merge, and there are enough points to form a cluster\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n          var wx = p.x * numPointsOrigin;\n          var wy = p.y * numPointsOrigin;\n          var clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null; // encode both zoom and point index on which the cluster originated -- offset by total length of features\n\n          var id = (i << 5) + (zoom + 1) + this.points.length;\n          var _iterator6 = _createForOfIteratorHelper(neighborIds),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var neighborId = _step6.value;\n              var b = tree.points[neighborId];\n              if (b.zoom <= zoom) continue;\n              b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n              var numPoints2 = b.numPoints || 1;\n              wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n\n              wy += b.y * numPoints2;\n              b.parentId = id;\n              if (reduce) {\n                if (!clusterProperties) clusterProperties = this._map(p, true);\n                reduce(clusterProperties, this._map(b));\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n          p.parentId = id;\n          clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n        } else {\n          // left points as unclustered\n          clusters.push(p);\n          if (numPoints > 1) {\n            var _iterator7 = _createForOfIteratorHelper(neighborIds),\n              _step7;\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var _neighborId = _step7.value;\n                var _b = tree.points[_neighborId];\n                if (_b.zoom <= zoom) continue;\n                _b.zoom = zoom;\n                clusters.push(_b);\n              }\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n          }\n        }\n      }\n      return clusters;\n    } // get index of the point from which the cluster originated\n  }, {\n    key: \"_getOriginId\",\n    value: function _getOriginId(clusterId) {\n      return clusterId - this.points.length >> 5;\n    } // get zoom of the point from which the cluster originated\n  }, {\n    key: \"_getOriginZoom\",\n    value: function _getOriginZoom(clusterId) {\n      return (clusterId - this.points.length) % 32;\n    }\n  }, {\n    key: \"_map\",\n    value: function _map(point, clone) {\n      if (point.numPoints) {\n        return clone ? extend({}, point.properties) : point.properties;\n      }\n      var original = this.points[point.index].properties;\n      var result = this.options.map(original);\n      return clone && result === original ? extend({}, result) : result;\n    }\n  }]);\n  return Supercluster;\n}();\nfunction createCluster(x, y, id, numPoints, properties) {\n  return {\n    x: fround(x),\n    // weighted cluster center; round for consistency with Float32Array index\n    y: fround(y),\n    zoom: Infinity,\n    // the last zoom the cluster was processed at\n    id: id,\n    // encodes index of the first child of the cluster and its zoom level\n    parentId: -1,\n    // parent cluster id\n    numPoints: numPoints,\n    properties: properties\n  };\n}\nfunction createPointCluster(p, id) {\n  var _p$geometry$coordinat = _slicedToArray(p.geometry.coordinates, 2),\n    x = _p$geometry$coordinat[0],\n    y = _p$geometry$coordinat[1];\n  return {\n    x: fround(lngX(x)),\n    // projected point coordinates\n    y: fround(latY(y)),\n    zoom: Infinity,\n    // the last zoom the point was processed at\n    index: id,\n    // index of the source feature in the original input array,\n    parentId: -1 // parent cluster id\n  };\n}\n\nfunction getClusterJSON(cluster) {\n  return {\n    type: 'Feature',\n    id: cluster.id,\n    properties: getClusterProperties(cluster),\n    geometry: {\n      type: 'Point',\n      coordinates: [xLng(cluster.x), yLat(cluster.y)]\n    }\n  };\n}\nfunction getClusterProperties(cluster) {\n  var count = cluster.numPoints;\n  var abbrev = count >= 10000 ? \"\".concat(Math.round(count / 1000), \"k\") : count >= 1000 ? \"\".concat(Math.round(count / 100) / 10, \"k\") : count;\n  return extend(extend({}, cluster.properties), {\n    cluster: true,\n    cluster_id: cluster.id,\n    point_count: count,\n    point_count_abbreviated: abbrev\n  });\n} // longitude/latitude to spherical mercator in [0..1] range\n\nfunction lngX(lng) {\n  return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n  var sin = Math.sin(lat * Math.PI / 180);\n  var y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n  return y < 0 ? 0 : y > 1 ? 1 : y;\n} // spherical mercator to longitude/latitude\n\nfunction xLng(x) {\n  return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n  var y2 = (180 - y * 360) * Math.PI / 180;\n  return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\nfunction extend(dest, src) {\n  for (var id in src) dest[id] = src[id];\n  return dest;\n}\nfunction getX(p) {\n  return p.x;\n}\nfunction getY(p) {\n  return p.y;\n}\nexport { Supercluster as default };","map":{"version":3,"names":["KDBush","defaultOptions","minZoom","maxZoom","minPoints","radius","extent","nodeSize","log","generateId","reduce","map","props","fround","Math","tmp","x","Float32Array","Supercluster","options","_classCallCheck","extend","Object","create","trees","Array","_createClass","key","value","load","points","_this$options","console","time","timerId","concat","length","clusters","i","geometry","push","createPointCluster","getX","getY","timeEnd","z","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","max","min","maxLng","maxLat","easternHem","westernHem","tree","_limitZoom","ids","range","lngX","latY","_iterator","_createForOfIteratorHelper","_step","s","n","done","id","c","numPoints","getClusterJSON","index","err","e","f","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","r","pow","within","y","children","_iterator2","_step2","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","_this$options2","p","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","result","skipped","_iterator3","_step3","child","cluster","point_count","_iterator4","_step4","isCluster","tags","px","py","getClusterProperties","coordinates","type","round","undefined","floor","_this$options3","neighborIds","numPointsOrigin","_iterator5","_step5","neighborId","b","wx","wy","clusterProperties","_map","_iterator6","_step6","numPoints2","createCluster","_iterator7","_step7","point","clone","original","Infinity","_p$geometry$coordinat","_slicedToArray","xLng","yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","exp","dest","src","default"],"sources":["/Users/eddiediedie/Desktop/CCC_A2/CCCA2/node_modules/gmap-vue/dist/esm/node_modules/.pnpm/supercluster@7.1.5/node_modules/supercluster/index.js"],"sourcesContent":["import KDBush from '../../../kdbush@3.0.0/node_modules/kdbush/src/index.js';\n\nconst defaultOptions = {\n  minZoom: 0,\n  // min zoom to generate clusters on\n  maxZoom: 16,\n  // max zoom level to cluster the points on\n  minPoints: 2,\n  // minimum points to form a cluster\n  radius: 40,\n  // cluster radius in pixels\n  extent: 512,\n  // tile extent (radius is calculated relative to it)\n  nodeSize: 64,\n  // size of the KD-tree leaf node, affects performance\n  log: false,\n  // whether to log timing info\n  // whether to generate numeric ids for input features (in vector tiles)\n  generateId: false,\n  // a reduce function for calculating custom cluster properties\n  reduce: null,\n  // (accumulated, props) => { accumulated.sum += props.sum; }\n  // properties to use for individual points when running the reducer\n  map: props => props // props => ({sum: props.my_value})\n\n};\n\nconst fround = Math.fround || (tmp => x => {\n  tmp[0] = +x;\n  return tmp[0];\n})(new Float32Array(1));\n\nclass Supercluster {\n  constructor(options) {\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n  }\n\n  load(points) {\n    const {\n      log,\n      minZoom,\n      maxZoom,\n      nodeSize\n    } = this.options;\n    if (log) console.time('total time');\n    const timerId = `prepare ${points.length} points`;\n    if (log) console.time(timerId);\n    this.points = points; // generate a cluster object for each point and index input points into a KD-tree\n\n    let clusters = [];\n\n    for (let i = 0; i < points.length; i++) {\n      if (!points[i].geometry) continue;\n      clusters.push(createPointCluster(points[i], i));\n    }\n\n    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n    if (log) console.timeEnd(timerId); // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n    // results in a cluster hierarchy across zoom levels\n\n    for (let z = maxZoom; z >= minZoom; z--) {\n      const now = +Date.now(); // create a new set of clusters for the zoom and index them with a KD-tree\n\n      clusters = this._cluster(clusters, z);\n      this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n      if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n    }\n\n    if (log) console.timeEnd('total time');\n    return this;\n  }\n\n  getClusters(bbox, zoom) {\n    let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n    const minLat = Math.max(-90, Math.min(90, bbox[1]));\n    let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n    const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n    if (bbox[2] - bbox[0] >= 360) {\n      minLng = -180;\n      maxLng = 180;\n    } else if (minLng > maxLng) {\n      const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n      const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n      return easternHem.concat(westernHem);\n    }\n\n    const tree = this.trees[this._limitZoom(zoom)];\n\n    const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n    const clusters = [];\n\n    for (const id of ids) {\n      const c = tree.points[id];\n      clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n    }\n\n    return clusters;\n  }\n\n  getChildren(clusterId) {\n    const originId = this._getOriginId(clusterId);\n\n    const originZoom = this._getOriginZoom(clusterId);\n\n    const errorMsg = 'No cluster with the specified id.';\n    const index = this.trees[originZoom];\n    if (!index) throw new Error(errorMsg);\n    const origin = index.points[originId];\n    if (!origin) throw new Error(errorMsg);\n    const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n    const ids = index.within(origin.x, origin.y, r);\n    const children = [];\n\n    for (const id of ids) {\n      const c = index.points[id];\n\n      if (c.parentId === clusterId) {\n        children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n      }\n    }\n\n    if (children.length === 0) throw new Error(errorMsg);\n    return children;\n  }\n\n  getLeaves(clusterId, limit, offset) {\n    limit = limit || 10;\n    offset = offset || 0;\n    const leaves = [];\n\n    this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n    return leaves;\n  }\n\n  getTile(z, x, y) {\n    const tree = this.trees[this._limitZoom(z)];\n\n    const z2 = Math.pow(2, z);\n    const {\n      extent,\n      radius\n    } = this.options;\n    const p = radius / extent;\n    const top = (y - p) / z2;\n    const bottom = (y + 1 + p) / z2;\n    const tile = {\n      features: []\n    };\n\n    this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.points, x, y, z2, tile);\n\n    if (x === 0) {\n      this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.points, z2, y, z2, tile);\n    }\n\n    if (x === z2 - 1) {\n      this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.points, -1, y, z2, tile);\n    }\n\n    return tile.features.length ? tile : null;\n  }\n\n  getClusterExpansionZoom(clusterId) {\n    let expansionZoom = this._getOriginZoom(clusterId) - 1;\n\n    while (expansionZoom <= this.options.maxZoom) {\n      const children = this.getChildren(clusterId);\n      expansionZoom++;\n      if (children.length !== 1) break;\n      clusterId = children[0].properties.cluster_id;\n    }\n\n    return expansionZoom;\n  }\n\n  _appendLeaves(result, clusterId, limit, offset, skipped) {\n    const children = this.getChildren(clusterId);\n\n    for (const child of children) {\n      const props = child.properties;\n\n      if (props && props.cluster) {\n        if (skipped + props.point_count <= offset) {\n          // skip the whole cluster\n          skipped += props.point_count;\n        } else {\n          // enter the cluster\n          skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped); // exit the cluster\n        }\n      } else if (skipped < offset) {\n        // skip a single point\n        skipped++;\n      } else {\n        // add a single point\n        result.push(child);\n      }\n\n      if (result.length === limit) break;\n    }\n\n    return skipped;\n  }\n\n  _addTileFeatures(ids, points, x, y, z2, tile) {\n    for (const i of ids) {\n      const c = points[i];\n      const isCluster = c.numPoints;\n      let tags, px, py;\n\n      if (isCluster) {\n        tags = getClusterProperties(c);\n        px = c.x;\n        py = c.y;\n      } else {\n        const p = this.points[c.index];\n        tags = p.properties;\n        px = lngX(p.geometry.coordinates[0]);\n        py = latY(p.geometry.coordinates[1]);\n      }\n\n      const f = {\n        type: 1,\n        geometry: [[Math.round(this.options.extent * (px * z2 - x)), Math.round(this.options.extent * (py * z2 - y))]],\n        tags\n      }; // assign id\n\n      let id;\n\n      if (isCluster) {\n        id = c.id;\n      } else if (this.options.generateId) {\n        // optionally generate id\n        id = c.index;\n      } else if (this.points[c.index].id) {\n        // keep id if already assigned\n        id = this.points[c.index].id;\n      }\n\n      if (id !== undefined) f.id = id;\n      tile.features.push(f);\n    }\n  }\n\n  _limitZoom(z) {\n    return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n  }\n\n  _cluster(points, zoom) {\n    const clusters = [];\n    const {\n      radius,\n      extent,\n      reduce,\n      minPoints\n    } = this.options;\n    const r = radius / (extent * Math.pow(2, zoom)); // loop through each point\n\n    for (let i = 0; i < points.length; i++) {\n      const p = points[i]; // if we've already visited the point at this zoom level, skip it\n\n      if (p.zoom <= zoom) continue;\n      p.zoom = zoom; // find all nearby points\n\n      const tree = this.trees[zoom + 1];\n      const neighborIds = tree.within(p.x, p.y, r);\n      const numPointsOrigin = p.numPoints || 1;\n      let numPoints = numPointsOrigin; // count the number of points in a potential cluster\n\n      for (const neighborId of neighborIds) {\n        const b = tree.points[neighborId]; // filter out neighbors that are already processed\n\n        if (b.zoom > zoom) numPoints += b.numPoints || 1;\n      } // if there were neighbors to merge, and there are enough points to form a cluster\n\n\n      if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n        let wx = p.x * numPointsOrigin;\n        let wy = p.y * numPointsOrigin;\n        let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null; // encode both zoom and point index on which the cluster originated -- offset by total length of features\n\n        const id = (i << 5) + (zoom + 1) + this.points.length;\n\n        for (const neighborId of neighborIds) {\n          const b = tree.points[neighborId];\n          if (b.zoom <= zoom) continue;\n          b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n          const numPoints2 = b.numPoints || 1;\n          wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n\n          wy += b.y * numPoints2;\n          b.parentId = id;\n\n          if (reduce) {\n            if (!clusterProperties) clusterProperties = this._map(p, true);\n            reduce(clusterProperties, this._map(b));\n          }\n        }\n\n        p.parentId = id;\n        clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n      } else {\n        // left points as unclustered\n        clusters.push(p);\n\n        if (numPoints > 1) {\n          for (const neighborId of neighborIds) {\n            const b = tree.points[neighborId];\n            if (b.zoom <= zoom) continue;\n            b.zoom = zoom;\n            clusters.push(b);\n          }\n        }\n      }\n    }\n\n    return clusters;\n  } // get index of the point from which the cluster originated\n\n\n  _getOriginId(clusterId) {\n    return clusterId - this.points.length >> 5;\n  } // get zoom of the point from which the cluster originated\n\n\n  _getOriginZoom(clusterId) {\n    return (clusterId - this.points.length) % 32;\n  }\n\n  _map(point, clone) {\n    if (point.numPoints) {\n      return clone ? extend({}, point.properties) : point.properties;\n    }\n\n    const original = this.points[point.index].properties;\n    const result = this.options.map(original);\n    return clone && result === original ? extend({}, result) : result;\n  }\n\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n  return {\n    x: fround(x),\n    // weighted cluster center; round for consistency with Float32Array index\n    y: fround(y),\n    zoom: Infinity,\n    // the last zoom the cluster was processed at\n    id,\n    // encodes index of the first child of the cluster and its zoom level\n    parentId: -1,\n    // parent cluster id\n    numPoints,\n    properties\n  };\n}\n\nfunction createPointCluster(p, id) {\n  const [x, y] = p.geometry.coordinates;\n  return {\n    x: fround(lngX(x)),\n    // projected point coordinates\n    y: fround(latY(y)),\n    zoom: Infinity,\n    // the last zoom the point was processed at\n    index: id,\n    // index of the source feature in the original input array,\n    parentId: -1 // parent cluster id\n\n  };\n}\n\nfunction getClusterJSON(cluster) {\n  return {\n    type: 'Feature',\n    id: cluster.id,\n    properties: getClusterProperties(cluster),\n    geometry: {\n      type: 'Point',\n      coordinates: [xLng(cluster.x), yLat(cluster.y)]\n    }\n  };\n}\n\nfunction getClusterProperties(cluster) {\n  const count = cluster.numPoints;\n  const abbrev = count >= 10000 ? `${Math.round(count / 1000)}k` : count >= 1000 ? `${Math.round(count / 100) / 10}k` : count;\n  return extend(extend({}, cluster.properties), {\n    cluster: true,\n    cluster_id: cluster.id,\n    point_count: count,\n    point_count_abbreviated: abbrev\n  });\n} // longitude/latitude to spherical mercator in [0..1] range\n\n\nfunction lngX(lng) {\n  return lng / 360 + 0.5;\n}\n\nfunction latY(lat) {\n  const sin = Math.sin(lat * Math.PI / 180);\n  const y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n  return y < 0 ? 0 : y > 1 ? 1 : y;\n} // spherical mercator to longitude/latitude\n\n\nfunction xLng(x) {\n  return (x - 0.5) * 360;\n}\n\nfunction yLat(y) {\n  const y2 = (180 - y * 360) * Math.PI / 180;\n  return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n  for (const id in src) dest[id] = src[id];\n\n  return dest;\n}\n\nfunction getX(p) {\n  return p.x;\n}\n\nfunction getY(p) {\n  return p.y;\n}\n\nexport { Supercluster as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}